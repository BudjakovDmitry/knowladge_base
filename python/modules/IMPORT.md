# Импортирование

```python
import some_module
```

Команда выше означает следующее: загрузить файл some_module.py (если он еще не был загржен) и открыть доступ ко всем его атрибутам через имя some_module. В коде будет создана переменная some_module и ей будет присвоен объект загруженного модуля.

Импортирование будет произведено *во время выполнения* программы.

Каждое имя, присвоенное на верхнем уровне файла, станодится атрибутом модуля, доступным клиенту. Для того чтобы создать эти объекты в импортируемом модуле, операция импорта на финальном шаге выполняет код в загруженном модуле.

## Как работает импортирование

Операция импорта делает три отдельных шага, когда модуль импортируется впервые.

1. Ищет файл модуля.
2. Компилирует его в байт-код (при необходимости).
3. Выполняет код модуля для создания объектов, которые в нем определены.

Попытка повторного импортирования того же самого модуля в ходе выполнения программы, обходит эти шаги и просто извлекает из памяти уже загруженный объект модуля. Формально, Python хранит загруженные модули в таблице `sys.modules` и просматривает ее в начале операции импортирования. Если модуль в таблице отсутствует, тогда запускается процесс из трех шагов. 

### Поиск файла модуля

Первым делом Python должен найти файл модуля. Python применяет *стандарнтый путь поиска модуля*

### Компиляция файла модуля (возможная)

После того, как посредством пути обхода модулей найден файл исходного кода, Python при необходимости компилирует его в байт-код. Во время операци имопортирования Python проверяет время модификации файлов исходного кода и байт-кода, чтобы решить, как поступить. В первом случае используются отметки времени файлов, а во вотром в зависимости от выпуска Python применяется либо "магическое число", встроенное в байт-код, либо имя файла.

#### Когда компилировать

Если файл байт-кода старше файла исходного кода (т.е. исходный код был модифицирован) или был создан другой версией Python, тогда Python автоматически заново генерирует байт-код при запуске программы.

В Python 3.2 и старше файлы байт-кода вынесены в отдельный подкаталог \_\_pycache\_\_ и содержат в своих именах версию Python во избежание конфликтов и перекомпиляции, когда в системе установлено множество версий Python: запуск под управдением выбранной версии не приводит к переписыванию одного байт-кода другим и не требует повторной компиляции. В результате устраняется необходимость в проверке номеров версий интерпретатора.

#### Когда не компилировать

Если файл байт-кода .pyc __не старше__ соответствующего файла исходного кода .py и создан той же версией интерпретатора, тогда шаг компиляции исходного кода в байт-код пропускается.

Когда Python находит в пути поиска модулей только файл байт-кода, и не находит файл исходного кода, он просто напрямую загружает байт-код. Таким образом, можно поставлять программу в виде только файлов байт-кода, не отправляя сами файлы исходного кода.

Компиляция происходит во время импортирвоания файла. Из-за этого обычно отсутствут файлы байт-кода .pyc для верхнего уровня программы. Лишь имопртированные файлы оставляют после себя файлы .pyc. Байт-код файлов верхнего уровня применяется внутрнне и отбрасывается, а байт-код импортирвоанных файлов сохраняется в файлах для ускорения будущих операций импортирования.

### Выполнение файла модуля

На финальном шаге операции импортирования выполняется байт-код модуля. Все операции в файле выполняются по очереди от начала до конца и любые присваивания именам на данном шаге генерируют атрибуты результирующего объекта модуля.

Из-за того, что последний шаг имопртирования выполняет код файла, если любой код верхнего уровня в файле модуля делает реальную работу, то ее результаты будут видны во время импортирования (например, операторы print верхнего уровня отобразят вывод при импортирвоании).

### Операция импортирования выполняется только один раз

Как видно, операции импортирвоания включают в себя довольно много раоты. Поэтому, любой модуль импортируется только один раз за процесс. Повторные операции импортирования пропускают все три шага и повторно используют уже загруженный модуль в памяти.

## Путь поиска модулей

Путь поиска модулей формируется объединением следующих компонентов, одни из которых установлены заранее, а другие можно настроить для указания интерпретатору, где искать.

1. Домашний каталог программы

   Когда мы запускаем программу, данный элемент представляет собой каталог, который содержит файл сценария верхнего уровня программы. При работе в интерактивном режиме, данным элментом является текущий рабочий каталог. Из-за того, что поиск в домашнем каталоге всегда происходит первым, если программа расположена целиком в единственном каталоге, тогда все ее операции импортирования будут работать, не требуя конфигурации путей поиска. С другой стороны, имена модулей в домашнем каталоге могут переопределить имена в каталогах ниже (например таким образом можно случайно скрыть библиотечный модуль)

2. Каталоги PYTHONPATH (если установлены)

   Представляет собой список каталогов, перечисленных в переменной окружения `PYTHONPATH` слева направо. Данная переменная не устанавливается автоматически. При необходимости ее нужно установить вручную, тем самым расширив путь поиска модулей.

3. Каталоги стандартной библиотеки

   Далее автоматически выполняется поиск в каталогах, куда установлены стандартные библиотечные модули.

4. Содержимое файлов .pth (при наличии)

   Python позволяет пользователям добавлять каталоги в путь поиска модулей, просто перечисляя их по одному в строке внутри текстового файла с расширением .pth. По сути это альтернатива настройки переменной окружения PYTHONPATH. Данный файл может находиться в директории site-packages. Когда такой файл присутствует, интерпретатор будет добавлять каталоги, перечисленные в каждой строке, в путь поиска модулей. Python соберет имена каталогов всех файлов .pth, которые найдет и отфильтрует любые дублированные и несуществующие каталоги. Поскольку это файлы, а не настройки оболочки, они могут применяться ко всем пользователям, а не только к одному пользователю или оболочке. Стандартный библиотечный модуль `site` позволяет настраивать местоположение файлов конфигурации путей и в его документации описаны ожидаемые местоположения файлов .pth

5. Подкаталог site-packages, в котором размещаются сторонние расширения

   Python автоматически добавляет в путь поиска модулей подкаталог `site-packages` своей стандартной библиотеки. По соглашению этот ккаталог представляет собой место, в которое устанавливается большинство сторонних расширений.

Объединение этих пяти компонентов образует `sys.path` - изменяемый список строк с именами каталогов. Поиск производится именно в том порядке, как он приведен в списке.

Второй и четвертый элементы можно применять для расширения пути, с целью включения собственных каталогов исходного кода в путь поиска модулей.

Следует отметить, что точнак конфигурация пути поиска может меняться среди платформ, выпусков Python и даже реализаций Python. В зависимости от имеющейся платформы к пути поиска модулей могут добавляться дополнительные каталоги. Например, некоторые выпуски Python могут добавлять в путь поиска перед каталогами PYTHONPATH текущий рабочий каталог - каталог, из которого запущена программа. При запуске из командной строки текущий рабочий каталог может отлечаться от домашнего каталога файла верхнего уровня.

## Выбор файла модуля

Расширения файлов (например, .py) намеренно не указываются в операциях import. Интерпретатор выбирает первый найденный в пути поиска файл, имя которого соответствует имени, указанному в операторе import. Операция import - это интерфейс ко множеству внешних компонентов - исходному коду, разновидностям байт-кода, скомпилированным расширениям и т.п. Интерпретатор автоматически выбирает любой вариант, дающий совпадение с именем модуля.

Оператор `import b` способен распознать и загрузить:

* файл исходного кода b.py;
* файл байт-кода b.pyc;
* файл оптимизированного байт-кода b.pyo;
* каталог по имени b для операций импортирования пакетов;
* скомпилированный модуль расширения, написанный на C, C++ или другом языке и динамически связываемый при импортировании (например b.so в Linux или b.dll и b.pyd в Windows);
* скомпилированный встроенный модуль, написанный на C и статически связанный с Python;
* компонент в файле ZIP, который автоматически извлекается при импортировании;
* образ в памяти для фиксированных исполняемых файлов;
* класс Java для верссии Jython;
* компонент .NET для версии IronPython.

Для импортера различия в типах загружаемых файлов совершенно несущественны как при импортировании, так и при извлечении атрибутов модулей. Оператор `import b` обеспечивает получение модуля b, чем бы он ни был, в соответствии с путем поиска модулей, а `b.attr` извлекает элемент из модуля, будь он переменной Python или связанной функцией C. Например, некоторые стандартные модули написаны на C, а не на Python, но поскольку они выглядят точно так же как файлы модулей на Python, пользователи могут не беспокоится об этом факте.

К примеру, у нас есть модуль script.py.

```python
# content of script.py
import sys

# Получить доуступ к объекту под именем platform из модуля sys
print(sys.platform)
print(2 ** 8)
x = 'Spam!'
print(x * 2)
```

Если мы в интерактивом сеансе имопртируем этот модуль, то получим такой результат:

```python
>>>import script
darwin
256
Spam!Spam!
```

Поскольку импорт - очень затратная операция, то в рамках одного процесса программы можно выполнять импорт модуля в файле только один раз. Повторные попытки импортировать ничего не дадут, даже если в соседнем окне изменить исходный код модуля и сохранить.

Любой файл способен импортировать инструменты из любого другого файла. Цепочки омпортирования могут иметь любую желаемую клубину.

## Перезагрузка модуля

Если нам необходимо повторно выполнить загрузку уже импортированного модуля, то потребуется функция `reload`, доступная в стандартном библиотечном модуле [importlib](../stl/IMPORTLIB.md)
