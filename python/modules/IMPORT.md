# Импортирование

```python
import some_module
```

Команда выше означает следующее: загрузить файл some_module.py (если он еще не был загржен) и открыть доступ ко всем его атрибутам через имя some_module. В коде будет создана переменная some_module и ей будет присвоен объект загруженного модуля.

Импортирование будет произведено *во время выполнения* программы.

Каждое имя, присвоенное на верхнем уровне файла, станодится атрибутом модуля, доступным клиенту. Для того чтобы создать эти объекты в импортируемом модуле, операция импорта на финальном шаге выполняет код в загруженном модуле.

## Как работает импортирование

Операция импорта делает три отдельных шага, когда модуль импортируется впервые.

1. Ищет файл модуля.
2. Компилирует его в байт-код (при необходимости).
3. Выполняет код модуля для создания объектов, которые в нем определены.

Попытка повторного импортирования того же самого модуля в ходе выполнения программы, обходит эти шаги и просто извлекает из памяти уже загруженный объект модуля. Формально, Python хранит загруженные модули в таблице `sys.modules` и просматривает ее в начале операции импортирования. Если модуль в таблице отсутствует, тогда запускается процесс из трех шагов. 

### Поиск файла модуля

Первым делом Python должен найти файл модуля. Python применяет *стандарнтый путь поиска модуля*

### Компиляция файла модуля (возможная)

После того, как посредством пути обхода модулей найден файл исходного кода, Python при необходимости компилирует его в байт-код. Во время операци имопортирования Python проверяет время модификации файлов исходного кода и байт-кода, чтобы решить, как поступить. В первом случае используются отметки времени файлов, а во вотром в зависимости от выпуска Python применяется либо "магическое число", встроенное в байт-код, либо имя файла.

#### Когда компилировать

Если файл байт-кода старше файла исходного кода (т.е. исходный код был модифицирован) или был создан другой версией Python, тогда Python автоматически заново генерирует байт-код при запуске программы.

В Python 3.2 и старше файлы байт-кода вынесены в отдельный подкаталог \__pycache\__ и содержат в своих именах версию Python во избежание конфликтов и перекомпиляции, когда в системе установлено множество версий Python: запуск под управдением выбранной версии не приводит к переписыванию одного байт-кода другим и не требует повторной компиляции. В результате устраняется необходимость в проверке номеров версий интерпретатора.

#### Когда не компилировать

Если файл байт-кода .pyc __не старше__ соответствующего файла исходного кода .py и создан той же версией интерпретатора, тогда шаг компиляции исходного кода в байт-код пропускается.

Когда Python находит в пути поиска модулей только файл байт-кода, и не находит файл исходного кода, он просто напрямую загружает байт-код. Таким образом, можно поставлять программу в виде только файлов байт-кода, не отправляя сами файлы исходного кода.

Компиляция происходит во время импортирвоания файла. Из-за этого обычно отсутствут файлы байт-кода .pyc для верхнего уровня программы. Лишь имопртированные файлы оставляют после себя файлы .pyc. Байт-код файлов верхнего уровня применяется внутрнне и отбрасывается, а байт-код импортирвоанных файлов сохраняется в файлах для ускорения будущих операций импортирования.

### Выполнение файла модуля

На финальном шаге операции импортирования выполняется байт-код модуля. Все операции в файле выполняются по очереди от начала до конца и любые присваивания именам на данном шаге генерируют атрибуты результирующего объекта модуля.

Из-за того, что последний шаг имопртирования выполняет код файла, если любой код верхнего уровня в файле модуля делает реальную работу, то ее результаты будут видны во время импортирования (например, операторы print верхнего уровня отобразят вывод при импортирвоании).

### Операция импортирования выполняется только один раз

Как видно, операции импортирвоания включают в себя довольно много раоты. Поэтому, любой модуль импортируется только один раз за процесс. Повторные операции импортирования пропускают все три шага и повторно используют уже загруженный модуль в памяти.

## Путь поиска модулей

Путь поиска модулей формируется объединением следующих компонентов, одни из которых установлены заранее, а другие можно настроить для указания интерпретатору, где искать.

1. Домашний каталог программы

   Когда мы запускаем программу, данный элемент представляет собой каталог, который содержит файл сценария верхнего уровня программы. При работе в интерактивном режиме, данным элментом является текущий рабочий каталог. Из-за того, что поиск в домашнем каталоге всегда происходит первым, если программа расположена целиком в единственном каталоге, тогда все ее операции импортирования будут работать, не требуя конфигурации путей поиска. С другой стороны, имена модулей в домашнем каталоге могут переопределить имена в каталогах ниже (например таким образом можно случайно скрыть библиотечный модуль)

2. Каталоги PYTHONPATH (если установлены)
3. Каталоги стандартной библиотеки
4. Содержимое файлов .pth (при наличии)
5. Подкаталог site-packages, в котором размещаются сторонние расширения

Объединение этих пяти компонентов образует `sys.path` - изменяемый список строк с именами каталогов. поиск производится именно в том порядке, как он приведен в списке.

Второй и четвертый элементы можно применять для расширения пути, с делью включения собственных каталогов исходного кода.

К примеру, у нас есть модуль script.py.

```python
# content of script.py
import sys

# Получить доуступ к объекту под именем platform из модуля sys
print(sys.platform)
print(2 ** 8)
x = 'Spam!'
print(x * 2)
```

Если мы в интерактивом сеансе имопртируем этот модуль, то получим такой результат:

```python
>>>import script
darwin
256
Spam!Spam!
```

Поскольку импорт - очень затратная операция, то в рамках одного процесса программы можно выполнять импорт модуля в файле только один раз. Повторные попытки импортировать ничего не дадут, даже если в соседнем окне изменить исходный код модуля и сохранить.

Любой файл способен импортировать инструменты из любого другого файла. Цепочки омпортирования могут иметь любую желаемую клубину.

## Перезагрузка модуля

Если нам необходимо повторно выполнить загрузку уже импортированного модуля, то потребуется функция `reload`, доступная в стандартном библиотечном модуле [importlib](../stl/IMPORTLIB.md)
