# Создание таблиц

Для создания таблиц служит команда `CREATE TABLE`.

```
CREATE TABLE table_name
(
   field_name type [constraints],
   field_name type [constraints],
   ...
   field_name type [constraints],
   [constraints],
   [primary_key],
   [foreign_key]
);
```
В квадратных скобках показаны необязательные элементы команды.

## Значения по умолчанию

Нередко возникают ситуации, когда то или иное значение является тепичным для для какого-то конкретного столбца. Значения по умолчанию задаются с помощью ключевого слова `DEFAULT`.

Например, при проектировании тиблицы "Успеваемость" студентов (progress), мы знаем, что как правило студенты получают оценки "отлично", и этот факт мы отразим при проектировании таблицы.

```sql
CREATE TABLE progress
(
   ...
   mark numeric(1) DEFAULT 5,
   ...
);
```

## Ограничения

### CHECK

Для его создания используется ключевое слово `CHECK`, за которым следует выражение в круглых скобках, содержащее одно или несколько условий, налагаемых на атрибуты таблицы. Это ограничение может быть двух уровней: уровня атрибута и уровня таблицы. Различия между ними только в синтаксическом оформлении. В обоих случаях в выражении могут содержаться обращения не только к одному, но и к нескольким атрибутам таблицы. В первом случае ограничение CHECK является частью определения одного конкретного атрибута, а во втором случае оно записывается как самостоятельный элемент определения таблицы.

Каждое ограничение имеет имя. Мы можем задать его сами с помощью ключевого слова CONSTRAINT. Если мы этого не сделаем, то СУБД сформирует имя автоматически. В простых случаях можно не давать ограничениям какие-либо специфичные имена, поскольку суть таких ограничений часто бывает очевидна. Но поскольку имена ограничений используются в сообщениях, которые выводит СУБД при попытке нарушения ограничений, все же можно придумать для них осмысленные имена, которые облегчат понимание ошибок.

Пример: ограничения, налагаемые на атрибуты term и mark из таблицы "Успеваемость". Семестр может иметь только два значения: 1 или 2. Оценка может иметь только три значения: 3, 4 или 5.

```sql
CREATE TABLE progress
(
   ...
   term numeric(1) CHECK (term = 1 OR term = 2),
   mark numeric(1) CHECK (mark >=3 AND mark <= 5),
   ...
);
```

### NOT NULL

В столбцах таблицы, на которые наложено такое ограничение, должны обязательно присутствовать какие-то определенные значения. Функционально оно эквивалентно ограничению CHECK (column_name IS NOT NULL). Но хорошей практикой является создание явного ограничения NOT NULL.

### UNIQUE

Такое ограничение, наложенное на конкретный столбец, означает, что все значения, содержащиеся в этом столбце, в различных строках таблицы, должны быть уникальными. Ограничение уникальности может включать в себя несколько столбцов. В этом случае уникальной должна быть комбинация их значений.

Пример задания ограничения столбца в определении таблицы

```sql
CREATE TABLE students
(
   record_book numeric(5) UNIQUE,
   ...
);
```

Ограничение можно задать, дав ему осмысленное имя.

```sql
CREATE TABLE students
(
   record_book numeric(5),
   ...
   CONSTRAINT unique_record_book UNIQUE (record_book),
   ...
);
```

Пример создания ограничения уникальности, включающее более одного столбца (комбинация значений серии и номера документа, удостоверяющего личность).

```sql
CREATE TABLE students
(
   ...
   doc_ser numeric(4),
   doc_num numeric(6),
   ...
   CONSTRAINT unique_passport UNIQUE (doc_ser, doc_num),
   ...
);
```

При добавлении ограничений уникальности автоматически создается индекс на основе В-дерева для поддержки этого ограничения.

## Первичный ключ

Первичный ключ является уникальным идентификатором строки в таблице. Ключ может быть простым (включать только один атрибут) или составным (включать более одного атрибута). Атрибуты, входящие в состав первичного ключа, не могут иметь значений NULL.

Если первичный ключ состоит из одного атрибута, то можно указать его непосредственно в определении атрибута.

```sql
CREATE TABLE students
(
   record_book numeric(5) PRIMARY KEY,
   ...
);
```

А можно сделать это в виде отдельного ограничения

```sql
CREATE TABLE students
(
   record_book numeric(5),
   ...
   PRIMARY KEY (record_book)
);
```

Образец создания составного первичного ключа

```sql
PRIMARY KEY (column_name_1, column_name_2, ...)
```

При добавлении первичного ключа автоматически создается индекс на основе B-дерева для поддержки этого ограничения.

Первичный ключ может быть только один. PostgreSQL допускает и отсутствие первичного ключа, хотя строгая теория реляционных баз данных не рекомендует так поступать.

## Внешний ключ (foreign key)

Внешние ключи являются средством поддержания ссылочной целостности (referential integrity) между связанными таблицами.

Таблица "Успеваемость" будет ссылающейся (referencing), а таблица "Студенты" ссылочной (referenced). Внешний ключ ссылающейся таблицы ссылается на первичный ключ ссылочной таблицы. Допускается ссылка на уникальный ключ, не являющийся первичным. Для описания отношений между таблицами можно сказать, что таблица students является главной, а таблица progress - подчиненной.

Создание внешнего ключа через ограничение атрибута

```sql
CREATE TABLE progress
(
   record_book numeric(5) REFERENCES students (record_book),
   ...
);
```

Теперь в таблицу progress нельзя ввести строку, значение атрибута record_book которой отсутствует в таблице students.

Если внешний ключ ссылается на первичный ключ, можно использовать сокращенную форму записи этого ограничения, не указывая список атрибутов.

```sql
CREATE TABLE progress
(
   record_book numeric(5) REFERENCES students,
   ...
);
```

Можно определить внешний ключ в формате ограничения уровня таблицы

```sql
CREATE TABLE progress
(
   record_book numeric(5),
   ...
   FOREIGN KEY (record_book) REFERENCES students (record_book)
);
```

Число атрибутов и их типы во внешнем ключе ссылающейся таблицы и в первичном ключе ссылочной таблицы должны быть согласованы.

Как и любому другому ограничению, ограничению внешнего ключа можно присвоить наименование с помощью ключевого слова CONSTRAINT.

При наличии связей между таблицами, организованных с помощью внешних ключей, особые ситуации возникают при удалении и обновлении строк в ссылочных таблицах (например, при удалении строки из таблицы students что делать со строками в таблице progress, которые ссылаются на удаляемого студента).

Возможны несколько вариантов

1. Удаление связанных строк в таблице progress. Это называется *каскадным удалением*. Для ее реализации в определение внешнего ключа добавляются ключевые слова `ON DELETE CASCADE`.

   ```sql
   CREATE TABLE progress
   (
      record_book numeric(5),
      ...
      FOREIGN KEY (record_book)
         REFERENCES students (record_book)
         ON DELETE CASCADE
   );
   ```

2. Запрет удаления строки из таблицы students, если в табице progress есть хотя бы одна строка, ссылающаяся на удаляемую строку в таблице students. Для этого нужно в определение внешнего ключа добавить ключевые слова: `ON DELETE RESTRICT` или `ON DELETE NO ACTION`. Оба эти варианта означают, что если в ссылающейся таблице есть строки, ссылающиеся на удаляемую строку в ссылочной таблице, то операция будет отменена и будет выведено сообщение об ошибке. Отличие между этими вариантами лишь в том, что при использовании NO ACTION можно отложить проверку выполнения ограничений на более поздний срок в рамках транзакции, а в случае RESTRICT проверка будет выполнена немедленно.

   ```sql
   CREATE TABLE progress
   (
      record_book numeric(5),
      ...
      FOREIGN KEY (record_book)
         REFERENCES students (record_book)
         ON DELETE RESTRICT
   );
   ```

3. Присваивание атрибутам внешнего ключа в строках ссылающейся таблицы значения NULL. Для реализации этого подхода необходимо, чтобы на атрибуты внешнего ключа не было наложено ограничение NOT NULL.

   ```sql
   CREATE TABLE progress
   (
      record_book numeric(5),
      ...
      FOREIGN KEY (record_book)
         REFERENCES students (record_book)
         ON DELETE SET NULL
   );
   ```

4. Присваивание атрибутам внешнего ключа в строках ссылащейся таблицы значения по умолчанию, если оно было предписано при создании таблицы. Важно учитывать, что если в ссылочной таблице нет строки с тем же значением ключевого атрибута, которое было указано в DEFAULT при создании ссылающейся таблицы, то произойдет нарушение ограничения ссылочной целостности и операция удаления не будет выполнена.

   ```sql
   CREATE TABLE progress
   (
      record_book numeric(5) DEFAULT 12345,
      ...
      FOREIGN KEY (record_book)
         REFERENCES students (record_book)
         ON DELETE SET DEFAULT
   );
   ```


Если в определении первичного ключа не предписано конкретное действие, то по умолчанию используется `NO ACTION`.

При выполнении операции `UPDATE` используются те же подходы к обеспечению ссылочной целостности.

```sql
CREATE TABLE progress
(
   record_book numeric(5),
   ...
   FOREIGN KEY (record_book)
      REFERENCES students (record_book)
      ON UPDATE CASCADE
);
```

В случае каскадного обновления измененные значения ссылочных атрибутов копируются в ссылающиеся строки ссылающейся таблицы.

Пример создания двух связанных таблиц

```sql
CREATE TABLE students
(
   record_book numeric(5) NOT NULL,
   name text NOT NULL,
   doc_ser numeric(4),
   doc_num numeric(6),
   PRIMARY KEY (record_book)
);

CREATE TABLE progress
(
   record_book numeric(5) NOT NULL,
   subject text NOT NULL,
   acad_year text NOT NULL,
   term numeric(1) NOT NULL CHECK (term = 1 OR term = 2),
   mark numeric(1) NOT NULL CHECK (mark >= 3 AND mark <= 5) DEFAULT 5
   FOREIGN KEY (record_book)
      REFERENCES students (record_book)
      ON DELETE CASCADE
      ON UPDATE CASCADE
);
```
