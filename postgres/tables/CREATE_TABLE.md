# Операции с таблицами

## Значения по умолчанию

Нередко возникают ситуации, когда то или иное значение является тепичным для для какого-то конкретного столбца. Когда добавляется новая строка и каким-то ее столбцам не присваиваются значения, эти столбцы принимают значения по умолчанию.

Значения по умолчанию задаются с помощью ключевого слова `DEFAULT`.

Если значение по умолчанию не объявлено, им считается значение NULL.

Например, при проектировании тиблицы "Успеваемость" студентов (progress), мы знаем, что как правило студенты получают оценки "отлично", и этот факт мы отразим при проектировании таблицы.

```sql
CREATE TABLE progress
(
   ...
   mark numeric(1) DEFAULT 5,
   ...
);
```

Значение по умолчанию может быть выражениемб которое вычисляется в момент присвоения значения по умолчанию (а не когда создается таблица). Например, столбцу timestamp в качестве значения по умолчанию часто присваевается CURRENT_TIMESTAMP, чтобы в момент добавленя строки в нем оказалось текущее время.

## Ограничения

У всех ограничений есть имена. Имена можно задавать либо самостоятельно, либо они будут сгенерированы автоматически. Имена можно посмотреть, выполнив запрос

```sql
SELECT constraint_name
FROM information_schema.key_column_usage
WHERE table_name = 'students' AND  --имя таблицы
      table_schema = 'public' AND  --имя схемы
      column_name = 'student_id';  --фильтр по конкретному столбцу
```

### CHECK

Ограничение-проверка.

Для его создания используется ключевое слово `CHECK`, за которым следует выражение в круглых скобках, содержащее одно или несколько условий, налагаемых на атрибуты таблицы. Это ограничение может быть двух уровней: уровня атрибута и уровня таблицы. Различия между ними только в синтаксическом оформлении. В обоих случаях в выражении могут содержаться обращения не только к одному, но и к нескольким атрибутам таблицы. В первом случае ограничение CHECK является частью определения одного конкретного атрибута, а во втором случае оно записывается как самостоятельный элемент определения таблицы.

Каждое ограничение имеет имя. Мы можем задать его сами с помощью ключевого слова CONSTRAINT. Если мы этого не сделаем, то СУБД сформирует имя автоматически. В простых случаях можно не давать ограничениям какие-либо специфичные имена, поскольку суть таких ограничений часто бывает очевидна. Но поскольку имена ограничений используются в сообщениях, которые выводит СУБД при попытке нарушения ограничений, все же можно придумать для них осмысленные имена, которые облегчат понимание ошибок.

Пример: ограничения, налагаемые на атрибуты term и mark из таблицы "Успеваемость". Семестр может иметь только два значения: 1 или 2. Оценка может иметь только три значения: 3, 4 или 5.

```sql
CREATE TABLE progress
(
   ...
   term numeric(1) CHECK (term = 1 OR term = 2),
   mark numeric(1) CHECK (mark >=3 AND mark <= 5),
   ...
);
```

Пример задания имени для ограничения

```sql
CREATE TABLE products
(
    product_no integer,
    name text,
    price numeric CONSTRAINT positive_price CHECK (price > 0)
);
```

Пример проверки, которая ссылается на несколько столбцов (мы храним цену товара и цену со скидкой и хотим гарантировать, что цена со скидкой будет всегда меньше обычной цены).

```sql
CRATE TABLE products
(
    product_no integer,
    name text,
    price numeric CHECK (price > 0),
    discounted_price numeric CHECK (discounted_price > 0),
    CHECK (price > discounted_price)
);
```

В примере выше первые два ограничения называются ограничениями столбцов, а третье является ограничением таблицы, так как оно написано отдельно от определений столбцов. Ограничения столбцов можно записать в виде ограничений таблицы, а обратное не всегда возможно, так как подразумевается, что ограничение столбца ссылается только на связанный столбец (PostgreSQL этого не требует, но для совместимости с другими СУБД лучше следовать этому правилу).

Пример выше можно переписать несколькими способами.

```sql
CRATE TABLE products
(
    product_no integer,
    name text,
    price numeric,
    CHECK (price > 0),
    discounted_price numeric,
    CHECK  (discounted_price > 0),
    CHECK (price > discounted_price)
);
```

```sql
CREATE TABLE products
(
    product_no integer,
    name text,
    price numeric CHECK (price > 0),
    discounted_price numeric,
    CHECK (discounted_price > 0 AND price > discounted_price)
);
```

Пример присваивания имени ограничению таблицы

```sql
CREATE TABLE products
(
    product_no integer,
    name text,
    price numeric,
    CHECK (price > 0),
    discounted_price numeric,
    CHECK (discounted_price  > 0),
    CONSTRAINT valid_discount CHECK (price > discounted_price)
);
```

Ограничение-проверка удовлетворяется, если выражение принимает значение true или NULL.

PostgreSQL не поддерживает ограничения CHECK, которые обращаются к данным, не относящимся к новой или измененной строке. Для определения ограничений, затрагивающих друге строки и другие таблицы, следует использовать ограничения UNIQUE, EXCLUDE, или FOREIGN KEY. Если нет необходимости в постоянной гарантии поддерживаемости целостности, а достаточно разовой проверки добавляемой строки по отношению к другим строкам, ножно реализовать эту проверку в собственном триггере.

Ограничения CHECK применяются только при добавлении или изменении строк, но не при обращении к ним. Возможна ситуация, когда в выражении CHECK используется пользовательская функция, поведение которой в последствии меняется. В результате часть строк в таблице перестанет удовлетворять ограничению CHECK и это останется незамеченным. В итоге при попытке загрузить выгруженные позже данные, могут возникнуть проблемы. Поэтому подобные изменения рекумендуется осуществлять следующим образом: удалить ограничение (используя ALTER TABLE), изменить определение функции, пересоздать ограничения той же командой, которая при этом перепроверит все строки таблицы.
