# Операции с таблицами

## Создание таблиц

Для создания таблиц служит команда `CREATE TABLE`. В этой команде как минимум нужно указать имя новой таблицы и имена и типы данных каждого столбца.

```
CREATE TABLE table_name
(
   field_name type [constraints],
   field_name type [constraints],
   ...
   field_name type [constraints],
   [constraints],
   [primary_key],
   [foreign_key]
);
```

Например, создадим таблицу products с двумя столбцами.

```sql
CREATE TABLE products
(
    product_no integer,
    name text,
    price numeric
);
```

В квадратных скобках показаны необязательные элементы команды.

При создании таблиц необходимо учитывать связи между ними. Сначала должны создаваться ссылочные таблицы, а потом ссылающиеся. Если в БД нет циклических ссылок таблиц друг на друга, то всегда существует хотя бы одна таблица, которая не ссылается ни на какие другие таблицы. С нее нужно начинать создание БД. Перед созданием очередной таблицы, имеющей внешние ключи, уже должны существовать все ссылочные таблицы для нее.

При наличии циклических ссылок таблиц дрцг на друга придется воспользоваться командой ALTER TABLE.

## Коммнетарии

PostgreSQL имеет расширение - команду COMMENT, которая позволяет создавать комментарии к различным объектам БД. Эти комментарии будут также сохраняться в базе данных.

```sql
COMMENT ON COLUMN table_name.column_name IS 'Comment or description here';
```

Посмотреть комментарии можно, например, через интерфейс psql.

```
\d+ table_name  # посмотреть комментарии к столбцам
```

## Значения по умолчанию

Нередко возникают ситуации, когда то или иное значение является тепичным для для какого-то конкретного столбца. Когда добавляется новая строка и каким-то ее столбцам не присваиваются значения, эти столбцы принимают значения по умолчанию.

Значения по умолчанию задаются с помощью ключевого слова `DEFAULT`.

Если значение по умолчанию не объявлено, им считается значение NULL.

Например, при проектировании тиблицы "Успеваемость" студентов (progress), мы знаем, что как правило студенты получают оценки "отлично", и этот факт мы отразим при проектировании таблицы.

```sql
CREATE TABLE progress
(
   ...
   mark numeric(1) DEFAULT 5,
   ...
);
```

Значение по умолчанию может быть выражениемб которое вычисляется в момент присвоения значения по умолчанию (а не когда создается таблица). Например, столбцу timestamp в качестве значения по умолчанию часто присваевается CURRENT_TIMESTAMP, чтобы в момент добавленя строки в нем оказалось текущее время.

## Ограничения

### CHECK

Ограничение-проверка.

Для его создания используется ключевое слово `CHECK`, за которым следует выражение в круглых скобках, содержащее одно или несколько условий, налагаемых на атрибуты таблицы. Это ограничение может быть двух уровней: уровня атрибута и уровня таблицы. Различия между ними только в синтаксическом оформлении. В обоих случаях в выражении могут содержаться обращения не только к одному, но и к нескольким атрибутам таблицы. В первом случае ограничение CHECK является частью определения одного конкретного атрибута, а во втором случае оно записывается как самостоятельный элемент определения таблицы.

Каждое ограничение имеет имя. Мы можем задать его сами с помощью ключевого слова CONSTRAINT. Если мы этого не сделаем, то СУБД сформирует имя автоматически. В простых случаях можно не давать ограничениям какие-либо специфичные имена, поскольку суть таких ограничений часто бывает очевидна. Но поскольку имена ограничений используются в сообщениях, которые выводит СУБД при попытке нарушения ограничений, все же можно придумать для них осмысленные имена, которые облегчат понимание ошибок.

Пример: ограничения, налагаемые на атрибуты term и mark из таблицы "Успеваемость". Семестр может иметь только два значения: 1 или 2. Оценка может иметь только три значения: 3, 4 или 5.

```sql
CREATE TABLE progress
(
   ...
   term numeric(1) CHECK (term = 1 OR term = 2),
   mark numeric(1) CHECK (mark >=3 AND mark <= 5),
   ...
);
```

Пример задания имени для ограничения

```sql
CREATE TABLE products
(
    product_no integer,
    name text,
    price numeric CONSTRAINT positive_price CHECK (price > 0)
);
```

Пример проверки, которая ссылается на несколько столбцов (мы храним цену товара и цену со скидкой и хотим гарантировать, что цена со скидкой будет всегда меньше обычной цены).

```sql
CRATE TABLE products
(
    product_no integer,
    name text,
    price numeric CHECK (price > 0),
    discounted_price numeric CHECK (discounted_price > 0),
    CHECK (price > discounted_price)
);
```

В примере выше первые два ограничения называются ограничениями столбцов, а третье является ограничением таблицы, так как оно написано отдельно от определений столбцов. Ограничения столбцов можно записать в виде ограничений таблицы, а обратное не всегда возможно, так как подразумевается, что ограничение столбца ссылается только на связанный столбец (PostgreSQL этого не требует, но для совместимости с другими СУБД лучше следовать этому правилу).

Пример выше можно переписать несколькими способами.

```sql
CRATE TABLE products
(
    product_no integer,
    name text,
    price numeric,
    CHECK (price > 0),
    discounted_price numeric,
    CHECK  (discounted_price > 0),
    CHECK (price > discounted_price)
);
```

```sql
CREATE TABLE products
(
    product_no integer,
    name text,
    price numeric CHECK (price > 0),
    discounted_price numeric,
    CHECK (discounted_price > 0 AND price > discounted_price)
);
```

Пример присваивания имени ограничению таблицы

```sql
CREATE TABLE products
(
    product_no integer,
    name text,
    price numeric,
    CHECK (price > 0),
    discounted_price numeric,
    CHECK (discounted_price  > 0),
    CONSTRAINT valid_discount CHECK (price > discounted_price)
);
```

Ограничение-проверка удовлетворяется, если выражение принимает значение true или NULL.

PostgreSQL не поддерживает ограничения CHECK, которые обращаются к данным, не относящимся к новой или измененной строке. Для определения ограничений, затрагивающих друге строки и другие таблицы, следует использовать ограничения UNIQUE, EXCLUDE, или FOREIGN KEY. Если нет необходимости в постоянной гарантии поддерживаемости целостности, а достаточно разовой проверки добавляемой строки по отношению к другим строкам, ножно реализовать эту проверку в собственном триггере.

Ограничения CHECK применяются только при добавлении или изменении строк, но не при обращении к ним. Возможна ситуация, когда в выражении CHECK используется пользовательская функция, поведение которой в последствии меняется. В результате часть строк в таблице перестанет удовлетворять ограничению CHECK и это останется незамеченным. В итоге при попытке загрузить выгруженные позже данные, могут возникнуть проблемы. Поэтому подобные изменения рекумендуется осуществлять следующим образом: удалить ограничение (используя ALTER TABLE), изменить определение функции, пересоздать ограничения той же командой, которая при этом перепроверит все строки таблицы.

### NOT NULL

Ограничение NOT NULL указывает, что столбцу нельзя присвоить значение NULL. Это ограничение всегда записывается как ограничение столбца. Функционально оно эквивалентно ограничению CHECK (column_name IS NOT NULL). Но хорошей практикой является создание явного ограничения NOT NULL, и работает оно более эффективно. Но у такой записи есть один недостаток - назначить имя таким ограничениям нельзя.

```sql
CREATE TABLE products
(
    product_no integer NOT NULL,
    name text NOT NULL,
    price numeric
);
```

### UNIQUE

Такое ограничение, наложенное на конкретный столбец, означает, что все значения, содержащиеся в этом столбце, в различных строках таблицы, должны быть уникальными. Ограничение уникальности может включать в себя несколько столбцов. В этом случае уникальной должна быть комбинация их значений.

Пример задания ограничения столбца в определении таблицы

```sql
CREATE TABLE students
(
   record_book numeric(5) UNIQUE,
   ...
);
```

Ограничение можно задать, дав ему осмысленное имя.

```sql
CREATE TABLE students
(
   record_book numeric(5),
   ...
   CONSTRAINT unique_record_book UNIQUE (record_book),
   ...
);
```

Пример создания ограничения уникальности, включающее более одного столбца (комбинация значений серии и номера документа, удостоверяющего личность).

```sql
CREATE TABLE students
(
   ...
   doc_ser numeric(4),
   doc_num numeric(6),
   ...
   CONSTRAINT unique_passport UNIQUE (doc_ser, doc_num),
   ...
);
```

При добавлении ограничений уникальности автоматически создается индекс на основе В-дерева для поддержки этого ограничения.

## Первичный ключ

Первичный ключ является уникальным идентификатором строки в таблице. Ключ может быть простым (включать только один атрибут) или составным (включать более одного атрибута). Атрибуты, входящие в состав первичного ключа, не могут иметь значений NULL.

Если первичный ключ состоит из одного атрибута, то можно указать его непосредственно в определении атрибута.

```sql
CREATE TABLE students
(
   record_book numeric(5) PRIMARY KEY,
   ...
);
```

А можно сделать это в виде отдельного ограничения

```sql
CREATE TABLE students
(
   record_book numeric(5),
   ...
   PRIMARY KEY (record_book)
);
```

Образец создания составного первичного ключа

```sql
PRIMARY KEY (column_name_1, column_name_2, ...)
```

Если в качестве первичного ключа используется значение, которое в реальности применяется на практике (например, серия и номер документа удостоверяющего личность), то такой первичный ключ называется **естественным**. Помимо естественных используются **суррогатные ключи**.

При добавлении первичного ключа автоматически создается индекс на основе B-дерева для поддержки этого ограничения.

Первичный ключ может быть только один. PostgreSQL допускает и отсутствие первичного ключа, хотя строгая теория реляционных баз данных не рекомендует так поступать.

## Внешний ключ (foreign key)

Внешние ключи являются средством поддержания ссылочной целостности (referential integrity) между связанными таблицами.

Таблица "Успеваемость" будет ссылающейся (referencing), а таблица "Студенты" ссылочной (referenced). Внешний ключ ссылающейся таблицы ссылается на первичный ключ ссылочной таблицы. Допускается ссылка на уникальный ключ, не являющийся первичным. Для описания отношений между таблицами можно сказать, что таблица students является главной, а таблица progress - подчиненной.

Создание внешнего ключа через ограничение атрибута

```sql
CREATE TABLE progress
(
   record_book numeric(5) REFERENCES students (record_book),
   ...
);
```

Теперь в таблицу progress нельзя ввести строку, значение атрибута record_book которой отсутствует в таблице students.

Если внешний ключ ссылается на первичный ключ, можно использовать сокращенную форму записи этого ограничения, не указывая список атрибутов.

```sql
CREATE TABLE progress
(
   record_book numeric(5) REFERENCES students,
   ...
);
```

Можно определить внешний ключ в формате ограничения уровня таблицы

```sql
CREATE TABLE progress
(
   record_book numeric(5),
   ...
   FOREIGN KEY (record_book) REFERENCES students (record_book)
);
```

Число атрибутов и их типы во внешнем ключе ссылающейся таблицы и в первичном ключе ссылочной таблицы должны быть согласованы.

Как и любому другому ограничению, ограничению внешнего ключа можно присвоить наименование с помощью ключевого слова CONSTRAINT.

При наличии связей между таблицами, организованных с помощью внешних ключей, особые ситуации возникают при удалении и обновлении строк в ссылочных таблицах (например, при удалении строки из таблицы students что делать со строками в таблице progress, которые ссылаются на удаляемого студента).

Возможны несколько вариантов

1. Удаление связанных строк в таблице progress. Это называется *каскадным удалением*. Для ее реализации в определение внешнего ключа добавляются ключевые слова `ON DELETE CASCADE`.

   ```sql
   CREATE TABLE progress
   (
      record_book numeric(5),
      ...
      FOREIGN KEY (record_book)
         REFERENCES students (record_book)
         ON DELETE CASCADE
   );
   ```

2. Запрет удаления строки из таблицы students, если в табице progress есть хотя бы одна строка, ссылающаяся на удаляемую строку в таблице students. Для этого нужно в определение внешнего ключа добавить ключевые слова: `ON DELETE RESTRICT` или `ON DELETE NO ACTION`. Оба эти варианта означают, что если в ссылающейся таблице есть строки, ссылающиеся на удаляемую строку в ссылочной таблице, то операция будет отменена и будет выведено сообщение об ошибке. Отличие между этими вариантами лишь в том, что при использовании NO ACTION можно отложить проверку выполнения ограничений на более поздний срок в рамках транзакции, а в случае RESTRICT проверка будет выполнена немедленно.

   ```sql
   CREATE TABLE progress
   (
      record_book numeric(5),
      ...
      FOREIGN KEY (record_book)
         REFERENCES students (record_book)
         ON DELETE RESTRICT
   );
   ```

3. Присваивание атрибутам внешнего ключа в строках ссылающейся таблицы значения NULL. Для реализации этого подхода необходимо, чтобы на атрибуты внешнего ключа не было наложено ограничение NOT NULL.

   ```sql
   CREATE TABLE progress
   (
      record_book numeric(5),
      ...
      FOREIGN KEY (record_book)
         REFERENCES students (record_book)
         ON DELETE SET NULL
   );
   ```

4. Присваивание атрибутам внешнего ключа в строках ссылащейся таблицы значения по умолчанию, если оно было предписано при создании таблицы. Важно учитывать, что если в ссылочной таблице нет строки с тем же значением ключевого атрибута, которое было указано в DEFAULT при создании ссылающейся таблицы, то произойдет нарушение ограничения ссылочной целостности и операция удаления не будет выполнена.

   ```sql
   CREATE TABLE progress
   (
      record_book numeric(5) DEFAULT 12345,
      ...
      FOREIGN KEY (record_book)
         REFERENCES students (record_book)
         ON DELETE SET DEFAULT
   );
   ```


Если в определении первичного ключа не предписано конкретное действие, то по умолчанию используется `NO ACTION`.

При выполнении операции `UPDATE` используются те же подходы к обеспечению ссылочной целостности.

```sql
CREATE TABLE progress
(
   record_book numeric(5),
   ...
   FOREIGN KEY (record_book)
      REFERENCES students (record_book)
      ON UPDATE CASCADE
);
```

В случае каскадного обновления измененные значения ссылочных атрибутов копируются в ссылающиеся строки ссылающейся таблицы.

Пример создания двух связанных таблиц

```sql
CREATE TABLE students
(
   record_book numeric(5) NOT NULL,
   name text NOT NULL,
   doc_ser numeric(4),
   doc_num numeric(6),
   PRIMARY KEY (record_book)
);

CREATE TABLE progress
(
   record_book numeric(5) NOT NULL,
   subject text NOT NULL,
   acad_year text NOT NULL,
   term numeric(1) NOT NULL CHECK (term = 1 OR term = 2),
   mark numeric(1) NOT NULL CHECK (mark >= 3 AND mark <= 5) DEFAULT 5
   FOREIGN KEY (record_book)
      REFERENCES students (record_book)
      ON DELETE CASCADE
      ON UPDATE CASCADE
);
```
