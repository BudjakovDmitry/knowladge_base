# Выборка данных

Для получения данных из таблицы предназначен оператор `SELECT`. Он состоит из нескольких частей: выборки (в которой перечисляются столбцы, которые должны быть получены), списка таблиц (в нем перечисляются таблицы, из которых будут получены данные) и необязательного условия (определяющего ограничения).

Пример получения всех строк в таблице:

```sql
SELECT * FROM tablename;
```

`*` говорит, что нужно извлечь все столбцы. Часто в производственом стиле писать `*` считается плохим тоном, так как рзультат таких запросов будет меняться при добавлении новых столбцов.

Можно перечислить список столбцов, которые нужно получить

```sql
SELECT column1, column2, column3
FROM tablename;
```

В списке выборки можно писать не только списки на столбцы, но и выражения. Для явного задания приоритета выполнения операторов можно использовать скобки.

```sql
SELECT column1,
       (column2+column3)/2 AS alias,
       column3
FROM tablname;
```

SQL поддреживает математические операции:

* `+` сложение
* `-` вычитание
* `*` умножение
* `/` деление
* `^` степень
* `|/` квадратный корень
* множество других операторов и функций

## Псевднимы

Оператор `AS` позволяет задать имя исходному столбцу (слово AS можно опустить).

```sql
SELECT count(*) AS employees_count
FROM employees;
```

Такими псевдонимами не получится воспользоваться в условии WHERE, потому что, когда отрабатывает WHERE, псевдонимы еще не назначены. Сначала отрабатывают FROM и WHERE, а потом SELECT. Аналогично не получится воспользоваться псевдонимами в HAVING.

Псевдонимами можно пользоваться в GROUP BY и ORDER BY, так как эти части отрабатывают после того, как произойдет SELECT. Также псевдонимы можно использоваться в подзапросах.

```sql
SELECT city, count(*) as employees_count
FROM employees
GROUP BY city
ORDER BY employees_count DESC;
```

```sql
SELECT category_id, SUM(unit_price * units_in_stock) AS total_price
FROM products
WHERE discontinued <> 1
GROUP BY category_id
HAVING SUM(unit_price * units_in_stock) > 5000 --не получится воспользоваться псевдонимом.
ORDER BY total_price DESC;
```

Псевдонмы можно давать таблицам.

```sql
SELECT *
FROM table_1 AS t1
    JOIN table_2 AS t2 ON t2.col_1 = t1.col_1
WHERE t1.col_2 is NULL;
```

## Конкатенация

```sql
SELECT first_name,
       last_name,
       first_name || ' ' || last_name AS concat_name
FROM employees;
```

first_name | last_name | concat_name
--- | --- | ---
John | Smith | John Smith
Dany | Robins | Dany Robins
Anna | Gray | Anna Gray

Еще можно использовать функцию `CONCAT`

```sql
SELECT first_name,
       last_name,
       CONCAT(first_name, ' ', last_name)
FROM employees;
```

## where

Запрос можно дополнить условием, добавив предложение `WHERE`, ограничивающее множество возвращаемых строк. В предложении WHERE указывается логическое выражение.

* a = b
* a > b
* a >= b
* a < b
* a <= b
* a <> b или a != b

В результирующей выборке окажутся только те строки, для которых это выражение истинно.

### and, or, not

Логические выражения можно комбинировать, используя операторы and, or и not.

Запрос ниже вернет только те строки, в которых значение поля column3 положительное, а значение column2 отрицательное

```sql
SELECT * FROM tablename WHERE column3 > 0 AND column2 < 0;
```

### between

Иногда нужно получить, где значение какого-либо параметра находится в заданном диапазоне. Это можно сделать объединив логическим И два условия.

```sql
SELECT *
FROM orders
WHERE price >= 20 AND price <= 50;
```

Существует альтернативный вариант с использованием ключевого слова `BETWEEN`.

```sql
SELECT *
FROM orders
WHERE price BETWEEN 20 AND 40;
```

При использовании `BETWEEN` верхняя и нижняя границы диапазона включаются в поисковую выдачу. Если границы не должны быть включены, between применять нельзя.

### in, not in

```sql
SELECT *
FROM customers
WHERE country IN ('Germany', 'USA', 'UK', 'Holland');
```

Будут выбраны все клиенты, проживающие в странах, указанных в списке.

```sql
SELECT *
FROM customers
WHERE country NOT IN ('Germany', 'USA', 'UK');
```

Будут выбраны все клиенты, которые проживают в странах, отличных от указанных в списке.

### any

Выбрать всех сотружников из филиалов в Москве.

```sql
SELECT *
FROM employees
WHERE department_id = ANY(SELECT department_id
                          FROM departments
                          WHERE city = 'Moscow');
```

### Like

Ключевое слово LIKE используется для поиска строк по шалону.

В шаблоне можно использовать служебные символы (placeholders):

* `%` - заполнитель означающий любое количество символов (в том числе 0)
* `_` - ровно 1 любой символ

Примеры:

* `LILE 'U%'` - строки, начинающиеся с U.
* `LIKE '%a'` - строки, оканчивающиеся на а.
* `LIKE '%John%'` - строки, содержащие John
* `LIKE 'J%n'` - строки, начинающиеся на J и кончающиеся на n
* `LIKE '_oh_'` - строки, где 2 и 3 символы oh, а первый и последний - любые
* `LIKE '_oh%'` - строки, где 2 и 3 символы - oh, первый - любой, в конце любое кодичество любых символов.

```sql
-- найти всех сотрудников, у которых имя оканчивается на -n
SELECT last_name, first_name
FROM employees
WHERE first_name LIKE '%n';
```

### Check on NULL

Ингода возникает задача отфильтровать строки по NULL. То есть найти строки, у которых какой-либо атрибут принимает значение NULL или наоборот не принимает значение NULL.

```sql
-- найти все заказы, которые еще не были отправлены
SELECT *
FROM orders
WHERE order_date IS NULL;

-- найти все отправленные заказы
SELECT *
FROM orders
WHERE order_date IS NOT NULL;
```

## Order by

Результат запроса можно отсортировать в нужном порядке с помощью предложения `ORDER BY`. Сортировать можно по одному или нескольким столбцам. Когда мы сортируем по нескольким столбцам, то сортировка по каждому следующему столбцу не будет нарушать сортировки по предыдущим столбцам.

Пример сортировки по одному столбцу.

```sql
SELECT * FROM tablename ORDER BY column1;
```

Пример сортировки по двум столбцам

```sql
SELECT * FROM tablename ORDER BY column1, column3;
```

Порядок сортировки задается ключевыми словами `ASC` (по возрастанию) и `DESC` (по убыванию). По умолчанию используется ASC.

```sql
SELECT DISTINCT country
FROM customers
ORDER BY country ASC;

SELECT DISTINCT country
FROM customers
ORDER BY country DESC;

SELECT DIXTINCT country, city
FROM customers
ORDER BY country ASC, city DESC
```

## Distinct

Можно убрать дублирующиеся строки из результата с помощью оператора `DISTINCT`.

```sql
SELECT DISTINCT column1 FROM tablename;
```

Выражние distinct может использоваться по нескольким колонкам. В этом случае будут выбраны записи, где уникальными являются комбинации выбранных значений.

```sql
SELECT DISTINCT column_1, column_2
FROM tablename;
```

## Limit

Limit ограничивает количество выводимых записей. Ключевое слово LIMIT ставится в запросе в самом конце.

```sql
-- вывести первые 10 имен сотрудников с вамилией Smith, отсортированных по дате их приема на работу.
SELECT first_name, last_name
FROM employees
WHERE last_name = 'Smith'
ORDER BY employment_date
LIMIT 10;
```

## Group by

Group by в запросе располагается между where и order by.

Пример: посчитать количество заказов, вес которых превышает 50 кг, отправляемых в каждую страну и отсортировать по колчеству.
```sql
SELECT ship_country, COUNT(*)
FROM orders
WHERE freight > 50
GROUP BY ship_country
ORDER BY COUNT(*) DESC;

-- посчитать сумму товаров в продаже по каждой категории
SELECT category_id, SUM(units_in_stock)
FROM products
GROUP BY category_id
ORDER BY SUM(units_in_stock) DESC
LIMIT 5;
```

### Having

HAVING, также как и WHERE, служит для фильтрации строк. Но where фильтрует строки до группировки, а having фильтрует после группировки. Соответственно, having имеет смысл использовать только вместе с group by.

```sql
-- вывести категории товаров, в которых продаж осуществляется больше чем на указанную сумму.
-- причем нас интересуют только те товары, которые будут впредь продаваться (discontinued <> 1)
SELECT category_id, SUM(unit_price * units_in_stock)
FROM products
WHERE discontinued <> 1
GROUP BY category_id
HAVING SUM(unit_price * units_in_stock) > 5000
ORDER BY SUM(unit_price * units_in_stock) DESC;
```

## Операции над множествами

В данном разделе описаны операции над множествами: объединение (union), пересечение (intersect) и исключение.

## Union

Union делает объединение результатов двух запросов.

Допустим, мы хотим вывести все страны, из которых наши заказчики и все страны, из которых наши сотрудники, чтобы это было в одной результирующей таблице. Сведения о заказчиках и сотрудниках хранятся в разных таблицах. Сначала мы получим страны из таблицы customer, потом получим страны из таблицы employees, а потом объединим результаты двух запросов с помощью оператора UNION.

```sql
SELECT country
FROM customers
UNION
SELECT country
FROM employees;
```

Если выполнит запрос выше, то результирующей таблице не будет дубликотов. Union убирает их из результирующей таблицы. Если мы хотим видеть результат как есть, со всеми дубликатами, то нужно использовать конструкцию `UNION ALL`.

```sql
SELECT country
FROM customers
UNION ALL
SELECT country
FROM employees;
```

## Intersect

Intersect делает пересечение двух множеств.

Допустим, нужно выбрать страны в которых есть и заказчики и сотрудники.

```sql
SELECT country
FROM customers
INTERSECT
SELECT country
FROM employees;
```

## Except

Делает исключение одного множества из другого множества (разница двух множеств).

Предположим, нужно выбрать страны, где прожимают заказчики, но не прожимают сотрудники.

```sql
SELECT country
FROM customers
EXCEPT
SELECT country
FROM employees;
```

Except работает следующим образом: берет множество уникальных значений из первого запроса и вычитает из него множество уникальных значений второго запроса. Результатом является множество уникальных значений, которые есть в первом множестве, и котрых нет во втором множестве. Например, в USA проживают 5 покупателей и 2 сотрудника. В результате в первом множестве USA втретится 1 раз и во втором множестве 1 раз. В результирующем множестве USA не будет.

Существует еще оператор `EXCEPT ALL`. Он работает не с множествами уникальных значений, а с полными множествами. Результатом является множество, содержащее все элементы первого множества, из которых вычли все элементы второго множества. Если в USA проживает 5 покупателей и 2 сотрудника, то в результирующем множестве USA втретится 3 раза (5 - 2).

```sql
SELECT country
FROM customer
EXCEPT ALL
SELECT country
FROM employees;
```

## Подзапросы

Поскольку запросы часто бывают сложными, бывает удобно выделить часть задачи и решить ее с помощью подзапроса. Бывают и такие задачи, которые без подзапросов реализовать либо крайне затруднительно, либо невозможно.

Зачастую запрос с подзапросом можно переписать так, чтобы избавиться от подзапроса (но не всегда). Обычно это делается с помощью соединения. Однако избавляться или нет от подзапроса нужно решать в индивидуально в каждом конкретном случае. В первую очередь нужно сравнить производительность. Ну а если если запрос с подзапросом также производителен, как и запрос с соединением, то надо сравнивать их читабельность. Бывает так, что запрос с подзапросом более читабелен, чем запрос с соединением. Зачастую, планировщик раскрывает запрос с подзапросом в запрос с соединением и выполняются они абсолютно одинаково.

Пример: мы хотим выбрать всех сотрудников, работающих в филиалах в Новосибирске

```sql
SELECT *
FROM employees
WHERE department_id IN (
    SELECT department_id
    FROM departments
    WHERE city = 'Novosibirsk'

-- этот запрос можно переписать с использованием соединения
SELECT *
FROM employees
    JOIN departments USING(department_id)
WHERE departments.city = 'Novosibirsk';
);
```

Пример: вывести информацию о товарах, которых на складе больше, чем товаров в среднем.

```sql
SELECT *
FROM products
WHERE units_in_stock > (
    SELECT AVG(units_in_stock)
    FROM products
)
ORDER BY units_in_stock;
```

Подзапрос может находится в разных частях основного запроса. Например, после LIMIT. Например, мы хотим вывести всех сотрудников из филиалов в Москве и лимитировать выборку по такому условию, которое необходимо вычислить: минимальный id департамента + 5 (пример исскуственный, но для демонстрации подойдет)

```sql
SELECT *
FROM employees
    JOIN departments d USING(department_id)
WHERE departments.city = 'Moscow'
LIMIT (SELECT MIN(department_id) + 5 FROM departments);
```

### where exists

Выражение exists является предикатом. Другими словами, выражение в подзапросе возвращает либо истину, либо ложь, и это является критерием того, будет выведена строка или нет в результирующую выборку.

Выражение exists подразумевает внешнее соединение: внутренний подзапрос объединяется определенным образом с внешним запросом.

Обобщенный синтаксис: как видно, происходит соединение по ключевым полям таблиц из внешнего запроса и подзапроса.

```sql
SELECT *
FROM table1 t1
WHERE EXISTS (SELECT 1
              FROM table2 t2
              WHERE t1.key = t2.key);
```

Пример: нужно вывести информацию о заказчиках, которые делали заказы весом от 50 до 100 едениц.

```sql
SELECT *
FROM customers
WHERE EXISTS (SELECT 1
              FROM ORDERS
              WHERE customer_id = customers.customer_id AND
                    freight BETWEEN 50 AND 100);
```

Машинерия этого запроса: СУБД смотрит на строку в таблице customers. Затем из таблицы orders извлекает все записи, где верно условие в подзапросе WHERE: customer_id из таблицы orders равен customer_id из строки во внешнем запросе (по сути - это join) и вес от 50 до 100. Если в таблице orders находится хотя бы одна такая запись, то выражение exists вернет true и запись из внешнего запроса попадет в результирующую выборку. Если записей в таблице orders не найдено, то exists вернет false и запись из внешнего запроса будет отфильтрована.

Условие exists можно инвертировать, используя NOT

```sql
SELECT *
FROM table1 t1
WHERE NOT EXISTS (SELECT 1
                  FROM table2 t2
                  WHERE t1.key = t2.key);
```

Как правило, where exists, как и остальные подзапросы можно переписать с помощью джойнов. В каждом конкретном случае нужно смотреть на производительность и читабельность.
