# Выборка данных

## Псевднимы

Оператор `AS` позволяет задать имя исходному столбцу (слово AS можно опустить).

```sql
SELECT count(*) AS employees_count
FROM employees;
```

Такими псевдонимами не получится воспользоваться в условии WHERE, потому что, когда отрабатывает WHERE, псевдонимы еще не назначены. Сначала отрабатывают FROM и WHERE, а потом SELECT. Аналогично не получится воспользоваться псевдонимами в HAVING.

Псевдонимами можно пользоваться в GROUP BY и ORDER BY, так как эти части отрабатывают после того, как произойдет SELECT. Также псевдонимы можно использоваться в подзапросах.

```sql
SELECT city, count(*) as employees_count
FROM employees
GROUP BY city
ORDER BY employees_count DESC;
```

```sql
SELECT category_id, SUM(unit_price * units_in_stock) AS total_price
FROM products
WHERE discontinued <> 1
GROUP BY category_id
HAVING SUM(unit_price * units_in_stock) > 5000 --не получится воспользоваться псевдонимом.
ORDER BY total_price DESC;
```

Псевдонмы можно давать таблицам.

```sql
SELECT *
FROM employees e
    JOIN departments d ON d.id = e.department_id
WHERE d.city = 'Tokyo';
```

## Конкатенация

```sql
SELECT first_name,
       last_name,
       first_name || ' ' || last_name AS concat_name
FROM employees;
```

first_name | last_name | concat_name
--- | --- | ---
John | Smith | John Smith
Dany | Robins | Dany Robins
Anna | Gray | Anna Gray

Еще можно использовать функцию `CONCAT`

```sql
SELECT first_name,
       last_name,
       CONCAT(first_name, ' ', last_name)
FROM employees;
```

## where

### ANY, ALL

Операторы (квантификаторы) ANY и ALL используются с предложением WHERE и HAVING. Внутри ANY и ALL пишутся подзапросы.

#### any

ANY возвращает true, если любое из всех значений, найденных подзапросом, удовлетворяет условию для текущей строки внешнего запроса.

Выбрать всех сотружников из филиалов в Москве. Подзапрос вернет идентификаторы филиалов в Москве. Внешний запрос будет проходить по строкам таблицы employees и возвращать те строки, где id филиала равняется любому из идентификаторов, которые вернул подзапрос.

```sql
SELECT *
FROM employees
WHERE department_id = ANY(SELECT department_id
                          FROM departments
                          WHERE city = 'Moscow');
```

#### all

ALL возвращает true, если все значения, найденные подзапросом, удовлетворяют условию для текущей строки внешнего запроса.

Функция ALL обычно применяется для получения выборки, характеризуемой значениями учитываемого столбца, которые больше (или меньше) всех значений того же столбца другой выборки, которая извлекается подзапросом.

Пример: получить список сотрудников, чья зарплата больше зарплаты любого сотрудника из московского филиала. Подзапрос выведет таблицу с единственным столбцом: зарплаты сотрудников в московских филиалах. Внешний запрос проверяет записи сотрудников и вернет тех, чьи зарплаты больше, чем значения из подзапроса.

```sql
SELECT *
FROM customers
WHERE salary > ALL(SELECT salary
                   FROM customers c JOIN department d USING(department_id)
                   WHERE d.city = 'Moscow');
```

### Like

Ключевое слово LIKE используется для поиска строк по шалону.

В шаблоне можно использовать служебные символы (placeholders):

* `%` - заполнитель означающий любое количество символов (в том числе 0)
* `_` - ровно 1 любой символ

Примеры:

* `LILE 'U%'` - строки, начинающиеся с U.
* `LIKE '%a'` - строки, оканчивающиеся на а.
* `LIKE '%John%'` - строки, содержащие John
* `LIKE 'J%n'` - строки, начинающиеся на J и кончающиеся на n
* `LIKE '_oh_'` - строки, где 2 и 3 символы oh, а первый и последний - любые
* `LIKE '_oh%'` - строки, где 2 и 3 символы - oh, первый - любой, в конце любое кодичество любых символов.

Регистр символов в шаблонах имеет значение.

```sql
-- найти всех сотрудников, у которых имя оканчивается на -n
SELECT last_name, first_name
FROM employees
WHERE first_name LIKE '%n';

-- найти всех сотрудников, у которых фамилия оканчивается НЕ на -ov
SELECT last_name, first_name
FROM employees
WHERE last_name NOT LIKE '%ov';
```

### Check on NULL

Ингода возникает задача отфильтровать строки по NULL. То есть найти строки, у которых какой-либо атрибут принимает значение NULL или наоборот не принимает значение NULL.

Для того, чтобы проверить значение на равенство NULL используется синтаксис: `IS NULL` и `IS NOT NULL`. Проверки вида `value = NULL` или `value != NULL` являются грубой ошибкой.

```sql
-- найти все заказы, которые еще не были отправлены
SELECT *
FROM orders
WHERE order_date IS NULL;

-- найти все отправленные заказы
SELECT *
FROM orders
WHERE order_date IS NOT NULL;
```

## Limit

Limit ограничивает количество выводимых записей. Ключевое слово LIMIT ставится в запросе в самом конце.

```sql
-- вывести первые 10 имен сотрудников с вамилией Smith, отсортированных по дате их приема на работу.
SELECT first_name, last_name
FROM employees
WHERE last_name = 'Smith'
ORDER BY employment_date
LIMIT 10;
```

## Group by

Group by в запросе располагается между where и order by.

Пример: посчитать количество заказов, вес которых превышает 50 кг, отправляемых в каждую страну и отсортировать по колчеству.
```sql
SELECT ship_country, COUNT(*)
FROM orders
WHERE freight > 50
GROUP BY ship_country
ORDER BY COUNT(*) DESC;

-- посчитать сумму товаров в продаже по каждой категории
SELECT category_id, SUM(units_in_stock)
FROM products
GROUP BY category_id
ORDER BY SUM(units_in_stock) DESC
LIMIT 5;
```

### Having

HAVING, также как и WHERE, служит для фильтрации строк. Но where фильтрует строки до группировки, а having фильтрует после группировки. Соответственно, having имеет смысл использовать только вместе с group by.

```sql
-- вывести категории товаров, в которых продаж осуществляется больше чем на указанную сумму.
-- причем нас интересуют только те товары, которые будут впредь продаваться (discontinued <> 1)
SELECT category_id, SUM(unit_price * units_in_stock)
FROM products
WHERE discontinued <> 1
GROUP BY category_id
HAVING SUM(unit_price * units_in_stock) > 5000
ORDER BY SUM(unit_price * units_in_stock) DESC;
```

## Операции над множествами

В данном разделе описаны операции над множествами: объединение (union), пересечение (intersect) и исключение.

## Union

Union делает объединение результатов двух запросов.

Допустим, мы хотим вывести все страны, из которых наши заказчики и все страны, из которых наши сотрудники, чтобы это было в одной результирующей таблице. Сведения о заказчиках и сотрудниках хранятся в разных таблицах. Сначала мы получим страны из таблицы customer, потом получим страны из таблицы employees, а потом объединим результаты двух запросов с помощью оператора UNION.

```sql
SELECT country
FROM customers
UNION
SELECT country
FROM employees;
```

Если выполнит запрос выше, то результирующей таблице не будет дубликотов. Union убирает их из результирующей таблицы. Если мы хотим видеть результат как есть, со всеми дубликатами, то нужно использовать конструкцию `UNION ALL`.

```sql
SELECT country
FROM customers
UNION ALL
SELECT country
FROM employees;
```

## Intersect

Intersect делает пересечение двух множеств.

Допустим, нужно выбрать страны в которых есть и заказчики и сотрудники.

```sql
SELECT country
FROM customers
INTERSECT
SELECT country
FROM employees;
```

## Except

Делает исключение одного множества из другого множества (разница двух множеств).

Предположим, нужно выбрать страны, где прожимают заказчики, но не прожимают сотрудники.

```sql
SELECT country
FROM customers
EXCEPT
SELECT country
FROM employees;
```

Except работает следующим образом: берет множество уникальных значений из первого запроса и вычитает из него множество уникальных значений второго запроса. Результатом является множество уникальных значений, которые есть в первом множестве, и котрых нет во втором множестве. Например, в USA проживают 5 покупателей и 2 сотрудника. В результате в первом множестве USA втретится 1 раз и во втором множестве 1 раз. В результирующем множестве USA не будет.

Существует еще оператор `EXCEPT ALL`. Он работает не с множествами уникальных значений, а с полными множествами. Результатом является множество, содержащее все элементы первого множества, из которых вычли все элементы второго множества. Если в USA проживает 5 покупателей и 2 сотрудника, то в результирующем множестве USA втретится 3 раза (5 - 2).

```sql
SELECT country
FROM customer
EXCEPT ALL
SELECT country
FROM employees;
```

## Подзапросы

Поскольку запросы часто бывают сложными, бывает удобно выделить часть задачи и решить ее с помощью подзапроса. Бывают и такие задачи, которые без подзапросов реализовать либо крайне затруднительно, либо невозможно.

Зачастую запрос с подзапросом можно переписать так, чтобы избавиться от подзапроса (но не всегда). Обычно это делается с помощью соединения. Однако избавляться или нет от подзапроса нужно решать в индивидуально в каждом конкретном случае. В первую очередь нужно сравнить производительность. Ну а если если запрос с подзапросом также производителен, как и запрос с соединением, то надо сравнивать их читабельность. Бывает так, что запрос с подзапросом более читабелен, чем запрос с соединением. Зачастую, планировщик раскрывает запрос с подзапросом в запрос с соединением и выполняются они абсолютно одинаково.

Пример: мы хотим выбрать всех сотрудников, работающих в филиалах в Новосибирске

```sql
SELECT *
FROM employees
WHERE department_id IN (
    SELECT department_id
    FROM departments
    WHERE city = 'Novosibirsk'

-- этот запрос можно переписать с использованием соединения
SELECT *
FROM employees
    JOIN departments USING(department_id)
WHERE departments.city = 'Novosibirsk';
);
```

Пример: вывести информацию о товарах, которых на складе больше, чем товаров в среднем.

```sql
SELECT *
FROM products
WHERE units_in_stock > (
    SELECT AVG(units_in_stock)
    FROM products
)
ORDER BY units_in_stock;
```

Подзапрос может находится в разных частях основного запроса. Например, после LIMIT. Например, мы хотим вывести всех сотрудников из филиалов в Москве и лимитировать выборку по такому условию, которое необходимо вычислить: минимальный id департамента + 5 (пример исскуственный, но для демонстрации подойдет)

```sql
SELECT *
FROM employees
    JOIN departments d USING(department_id)
WHERE departments.city = 'Moscow'
LIMIT (SELECT MIN(department_id) + 5 FROM departments);
```

Подзапросы можно соединять с внешними запросами

```sql
SELECT column_1, column_2
FROM table_1 AS t1 JOIN (
    SELECT column_1, column_2
    FROM table_2
) AS t2 ON t1.column_1 = t2.column_1
```

### where exists

Выражение exists является предикатом. Другими словами, выражение в подзапросе возвращает либо истину, либо ложь, и это является критерием того, будет выведена строка или нет в результирующую выборку.

Выражение exists подразумевает внешнее соединение: внутренний подзапрос объединяется определенным образом с внешним запросом.

Обобщенный синтаксис: как видно, происходит соединение по ключевым полям таблиц из внешнего запроса и подзапроса.

```sql
SELECT *
FROM table1 t1
WHERE EXISTS (SELECT 1
              FROM table2 t2
              WHERE t1.key = t2.key);
```

Пример: нужно вывести информацию о заказчиках, которые делали заказы весом от 50 до 100 едениц.

```sql
SELECT *
FROM customers
WHERE EXISTS (SELECT 1
              FROM ORDERS
              WHERE customer_id = customers.customer_id AND
                    freight BETWEEN 50 AND 100);
```

Машинерия этого запроса: СУБД смотрит на строку в таблице customers. Затем из таблицы orders извлекает все записи, где верно условие в подзапросе WHERE: customer_id из таблицы orders равен customer_id из строки во внешнем запросе (по сути - это join) и вес от 50 до 100. Если в таблице orders находится хотя бы одна такая запись, то выражение exists вернет true и запись из внешнего запроса попадет в результирующую выборку. Если записей в таблице orders не найдено, то exists вернет false и запись из внешнего запроса будет отфильтрована.

Условие exists можно инвертировать, используя NOT

```sql
SELECT *
FROM table1 t1
WHERE NOT EXISTS (SELECT 1
                  FROM table2 t2
                  WHERE t1.key = t2.key);
```

Как правило, where exists, как и остальные подзапросы можно переписать с помощью джойнов. В каждом конкретном случае нужно смотреть на производительность и читабельность.
