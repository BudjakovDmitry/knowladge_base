# Выборка данных

## Конкатенация

```sql
SELECT first_name,
       last_name,
       first_name || ' ' || last_name AS concat_name
FROM employees;
```

first_name | last_name | concat_name
--- | --- | ---
John | Smith | John Smith
Dany | Robins | Dany Robins
Anna | Gray | Anna Gray

Еще можно использовать функцию `CONCAT`

```sql
SELECT first_name,
       last_name,
       CONCAT(first_name, ' ', last_name)
FROM employees;
```

## where

### ANY, ALL

Операторы (квантификаторы) ANY и ALL используются с предложением WHERE и HAVING. Внутри ANY и ALL пишутся подзапросы.

#### any

ANY возвращает true, если любое из всех значений, найденных подзапросом, удовлетворяет условию для текущей строки внешнего запроса.

Выбрать всех сотружников из филиалов в Москве. Подзапрос вернет идентификаторы филиалов в Москве. Внешний запрос будет проходить по строкам таблицы employees и возвращать те строки, где id филиала равняется любому из идентификаторов, которые вернул подзапрос.

```sql
SELECT *
FROM employees
WHERE department_id = ANY(SELECT department_id
                          FROM departments
                          WHERE city = 'Moscow');
```

#### all

ALL возвращает true, если все значения, найденные подзапросом, удовлетворяют условию для текущей строки внешнего запроса.

Функция ALL обычно применяется для получения выборки, характеризуемой значениями учитываемого столбца, которые больше (или меньше) всех значений того же столбца другой выборки, которая извлекается подзапросом.

Пример: получить список сотрудников, чья зарплата больше зарплаты любого сотрудника из московского филиала. Подзапрос выведет таблицу с единственным столбцом: зарплаты сотрудников в московских филиалах. Внешний запрос проверяет записи сотрудников и вернет тех, чьи зарплаты больше, чем значения из подзапроса.

```sql
SELECT *
FROM customers
WHERE salary > ALL(SELECT salary
                   FROM customers c JOIN department d USING(department_id)
                   WHERE d.city = 'Moscow');
```

## Подзапросы

Поскольку запросы часто бывают сложными, бывает удобно выделить часть задачи и решить ее с помощью подзапроса. Бывают и такие задачи, которые без подзапросов реализовать либо крайне затруднительно, либо невозможно.

Зачастую запрос с подзапросом можно переписать так, чтобы избавиться от подзапроса (но не всегда). Обычно это делается с помощью соединения. Однако избавляться или нет от подзапроса нужно решать в индивидуально в каждом конкретном случае. В первую очередь нужно сравнить производительность. Ну а если если запрос с подзапросом также производителен, как и запрос с соединением, то надо сравнивать их читабельность. Бывает так, что запрос с подзапросом более читабелен, чем запрос с соединением. Зачастую, планировщик раскрывает запрос с подзапросом в запрос с соединением и выполняются они абсолютно одинаково.

Пример: мы хотим выбрать всех сотрудников, работающих в филиалах в Новосибирске

```sql
SELECT *
FROM employees
WHERE department_id IN (
    SELECT department_id
    FROM departments
    WHERE city = 'Novosibirsk'

-- этот запрос можно переписать с использованием соединения
SELECT *
FROM employees
    JOIN departments USING(department_id)
WHERE departments.city = 'Novosibirsk';
);
```

Пример: вывести информацию о товарах, которых на складе больше, чем товаров в среднем.

```sql
SELECT *
FROM products
WHERE units_in_stock > (
    SELECT AVG(units_in_stock)
    FROM products
)
ORDER BY units_in_stock;
```

Подзапрос может находится в разных частях основного запроса. Например, после LIMIT. Например, мы хотим вывести всех сотрудников из филиалов в Москве и лимитировать выборку по такому условию, которое необходимо вычислить: минимальный id департамента + 5 (пример исскуственный, но для демонстрации подойдет)

```sql
SELECT *
FROM employees
    JOIN departments d USING(department_id)
WHERE departments.city = 'Moscow'
LIMIT (SELECT MIN(department_id) + 5 FROM departments);
```

Подзапросы можно соединять с внешними запросами

```sql
SELECT column_1, column_2
FROM table_1 AS t1 JOIN (
    SELECT column_1, column_2
    FROM table_2
) AS t2 ON t1.column_1 = t2.column_1
```

### where exists

Выражение exists является предикатом. Другими словами, выражение в подзапросе возвращает либо истину, либо ложь, и это является критерием того, будет выведена строка или нет в результирующую выборку.

Выражение exists подразумевает внешнее соединение: внутренний подзапрос объединяется определенным образом с внешним запросом.

Обобщенный синтаксис: как видно, происходит соединение по ключевым полям таблиц из внешнего запроса и подзапроса.

```sql
SELECT *
FROM table1 t1
WHERE EXISTS (SELECT 1
              FROM table2 t2
              WHERE t1.key = t2.key);
```

Пример: нужно вывести информацию о заказчиках, которые делали заказы весом от 50 до 100 едениц.

```sql
SELECT *
FROM customers
WHERE EXISTS (SELECT 1
              FROM ORDERS
              WHERE customer_id = customers.customer_id AND
                    freight BETWEEN 50 AND 100);
```

Машинерия этого запроса: СУБД смотрит на строку в таблице customers. Затем из таблицы orders извлекает все записи, где верно условие в подзапросе WHERE: customer_id из таблицы orders равен customer_id из строки во внешнем запросе (по сути - это join) и вес от 50 до 100. Если в таблице orders находится хотя бы одна такая запись, то выражение exists вернет true и запись из внешнего запроса попадет в результирующую выборку. Если записей в таблице orders не найдено, то exists вернет false и запись из внешнего запроса будет отфильтрована.

Условие exists можно инвертировать, используя NOT

```sql
SELECT *
FROM table1 t1
WHERE NOT EXISTS (SELECT 1
                  FROM table2 t2
                  WHERE t1.key = t2.key);
```

Как правило, where exists, как и остальные подзапросы можно переписать с помощью джойнов. В каждом конкретном случае нужно смотреть на производительность и читабельность.
