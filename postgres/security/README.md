# Пользователи и роли

Одна из основных проблем безопасности БД - это управление пользователями и их доступом к данным. Самый частый подход для управления доступом - создать пользовательские роли и назначить эти роли пользователям.

__Роль__ - это совокупность разрешений и запретов на доступ к БД и ее объектам.

__Пользователь__ - это учетная запись с логином и паролем.

В PostgreSQL есть только роли. Пользователи - это роли с паролями. На поль с паролем назначают роль с прописанными доступами. По сути, можно создавать дерево ролей, поскольку разрешена вложенность: роль может основываться на другой роли.

Иногда роли называют __группами__.

Роли не привязываются к конеретной БД. Они создаются на уровне экземпляра сервера.

## Уровни безопасности

В PostgreSQL рассматривают 6 уровней безопасности.

* Уровень экземпляра (кластера/сервера/инсталляции): аутентификация, создание БД, управление безопасностью и т.д.

* Базы данных: подключение к конкретной БД, создание в ней ролей и т.д.

* Схемы: управление схемами (создание, удаление).

* Таблицы: CRUD-операции над таблицами.

* Колонки: операции над конкретной колонкой конкретной таблицы.

* Строки таблицы.

## Создание роли и серверные привилегии

Синтаксис создания роли

```sql
CREATE ROLE role_name [PRIVILEGE];
```

PRIVILEGE - это привилегии серверного уровня. Значения могут быть:

* LOGIN [NOLOGIN] - позволяет логинится
* SUPERUSER [NOSUPERUSER] - обходит все проверки безопасности кроме необходимости залогиниться. Это очень опасная привилегия, и ее следует давать с большой осторожностью. По best practice даже администратору следует работать не из под суперюзера, чтобы случайно не запустить какую-нибудь нехорошую команду. Нового суперюзера можно создать только из-под роли суперюзера.
* CREATEDB [NOCREATEDB] Позволяет роли создавать базы данных
* CREATEROLE [NOCREATEROLE] С этой привилегией можно изменять и удалять другие роли. Можно предоставлять и забирать членство в других ролях. Однако, чтобы удалить роль суперюзера нужно иметь статус суперюзера.
* REPLICATION [NOREPLICATION] Привилегия дающая право на управление репликациями.

По умолчанию, если привилегию не прописываем, то по умолачнию везде применяется NO: nologin, nosuperuser, и т.д. Т.е. чтобы дать какую-то привилегию, ее нужно явно прописать.

Если роли дать привилегию createrole, то это не значит, что эта роль может создавать базы данных; или роли дали привилегию createdb, это не значит, что роль может создавать другие роли. То есть приилегия createdb не "старше" привилегии createrole. Привилении нужно назначать в зависимости от того, что мы хотим чтобы роль делала.

Посмотреть список ролей

```sql
SELECT rolname FROM pg_roles;
```

В этом списке будет роль __postgres__ - это роль, создаваемая по умолчанию, и единственная, имеющая привилегии superuser.

Примеры:

```sql
-- приведенные ниже две команды идентичны
CREATE ROLE role_name LOGIN;
CREATE USER user_name;

-- пароль указывается в кавычках
-- пароль шифруется алгоритмом md5
CREATE USER user_name WITH PASSWORD '*******';

-- создать "бесправную" роль
CREATE ROLE role_name;
```

Пароли пользователей баз данных хранятся отдельно от паролей пользователей операционной системы.

## Best practice по управлению безопасностью.

* Не работать с кластером из под superuser (например, postgres). В идеале создать пользователя с привилегиями createdb и createrole и работать из-под него.
* Когда с БД работают приложения, то следует продумать отдельные роли для отдельных приложений по сценарию использования: readonly, readwrite
* Следует давать минимальные права, трубуемые ролями.
* Следовать принципу: "все запрещено, что не разрешено". Сначала следует изъять все права, а потом добавить те, которые абсолютно необходимы.
* Роли следует создавать по акторам приложения: hr_user, reporting_user, admin_stuff.
* Нужно помнить тонкий момент: если на пользователя назначены две роли, и одна запрещает создание БД, а другая разрешает то разрешение в приоритете.
* При создании БД, создается схема public и скрытая роль public с доступом на запись в схему public.
* Всем новым ролям/пользователям неявно даются привилегии роли public. Это может быть проблемой, когда мы хотим создать пользователя с правами только на чтение: если мы удалим все привелегии, то разрешения, унаследованные через роль public, позволят пользователю создавать объекты в схеме public. Чтобы это исправить, нужно изъять права на создание у роли public на схеме public

```sql
REVOKE CREATE ON SCHEMA public FROM public;
```

* Желательно выполнить еще команду, которая запретит коннектится к конкретной БД из-под роли public 

```sql
REVOKE ALL ON DATABASE db_name FROM public;
```

* Приведенные выше две команды повлияют на всех пользователей. Поэтому, прежде чем запускать их, нужно выбать пользователям явные права на коннект к БД и возможность оперирования схемой.

* Остерегаться привилегии CREATEROLE. Если пользователь имеет привилегию CREATEROLE, но не CREATEDB, то он может создать новую роль с правами CREATEDB и обладать правами: CREATEROLE и CREATEDB. CREATEROLE - почти SUPERUSER.

## Предоставление доступа к таблице

```sql
GRANT operation ON TABLE table_name TO role;
```

operation - операция, которую пользователь сможет делать: SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES (создание внешних ключей), TRIGGER (создание триггеров). Операции можно перечислять через запятую

```sql
GRANT select, insert, update NO TABLE employee TO admin_user;
```

Предоставить доступ на операцию ко всем таблицам в определенной схеме:

```sql
GRAND operation ON ALL TABLES IN SCHEMA schema_name TO role;
```

## Предоставление доступа к колонкам

```sql
GRANT operation (columns) ON TABLE table_name TO role;
```

operation: SELECT, INSERT, UPDATE, REFERENCES (возможность ссылаться на колонки с внешним ключом).

columns - список колонок

## Предоставление доступа к строкам

Данный вид ограничения нужно включать явно командой:

```sql
ALTER TABLE table_name ENABLE ROW LEVEL SECURITY;
```

После включения row-level security доступ к данным запрещен. Теперь необходимо давать доступ явно через политику:

```sql
CREATE POLICY policy_name ON table_name
FOR operation TO role
USING (expression);
```

* policy_name - наименование политики
* table_name - наименование таблицы
* operation - операции (SELECT, INSERT, ...)
* role - имя роли

Две и более политики работают как запросы с UNION между ними, т.е. в результирующий набор будут включаться все данные из этих политик, даже если они по смыслу друг другу противоречат.

Удалить политику:

```sql
DROP POLICY policy_name ON table_name;
```

## Удаление роли

Чтобы удилить роль, необходимо:

1. Изъять все ранее выданные права
2. Переназначить все объекты, которыми владела удаляемая роль, на другую роль

```sql
-- передат владение таблицами
ALTER TABLE table_name OWNER TO other_role;
```

3. Незначимые объекты, которыми владела удаляемая роль можно удалить автоматом

```sql
DROP OWNED BY deleting_role [CASCADE][RESTRICT]
-- restrict означает, что объекты, которыми владее роль, не будут удаляться,
-- если в других базах есть объекты, которые от них зависят.
-- cascade - будет попытка удалить все зависимые объекты.
-- RESTRICT is default
```

Чтобы изъять все права на таблицы у какой-то роли, нужно запустить команду:

```sql
REVOKE ALL PRIVELEGES ON table1, table2,... FROM deleting_role;
```

Снять доступ к БД с роли:

```sql
REVOKE ALL ON DATABASSE db_name FROM deleting_role;
```

Снять доступ к схеме с роли:

```sql
REVOKE ALL ON SCHEMA schema_name FROM deleting_role;
```

Инымы словами - удаляем все зависимые объекты и удаляем все выданные права. И в самом конце удаляем роль

```sql
DROP ROLE [IF EXISTS] deleting_role;
```
