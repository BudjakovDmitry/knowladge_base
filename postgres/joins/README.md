# Соединения

Запросы на выборку данных могут обращаться сразу к нескольким таблицам, или обращаться к одной и той же таблице так, что одновременно будут обрабатываться разные наборы ее строк. Такой запрос называется *соединением* (`JOIN`).

Рассмотрим две таблицы:

__weather__

city | temp_lo | temp_hi | prcp | date
:---: | :---: | :---: | :---: | :---:
'San Francisco' | 46 | 50 | 0.25 | '1994-11-27'
'San Francisco' | 43 | 57 | 0.0 | '1994-11-29'
'Hayward' | 37 | 54 || '1994-11-29'

__cities__

name | location
:---: | :---:
'San Francisco' | '(-194.0, 53.0)'

## Внутренние соединения

Например, мы захотели перечислить все погодные события вместе с координатами соответствующих городов. Для этого мы должны сравнить столбец city каждой строки таблицы weather со столбцом name всех строк таблицы cities и выбрать пары строк, для которых эти значения совпадают (обычно соединения выполняются эффективнее и сравниваются не все возможные пары строк). Это можно сделать с помощью запроса:

```sql
SELECT *
    FROM weather, cities
    WHERE city = name;
```

В результате получим

city | temp_lo | temp_hi | prcp | date | name | location
---: | ---: | ---: | ---: | ---: | ---: | ---:
San Francisco | 46 | 50 | 0.25 | 1994-11-27 | San Francisco | (-194,53)
San Francisco | 43 | 57 | 0 | 1994-11-29 | San Francisco | (-194,53)

Следует обратить внимание на две особенности:

* В результате нет строки с городом Hayward. Так получилось потому, что в таблице cities нет строки для данного города, а при соединении все строки таблицы weather, для которых не нашлось соответствие, опускаются.
* Название города оказалось в двух столбцах. На практике это нежелательно, поэтому лучше перечислять нужные столбцы явно, а не использовать *.

```sql
SELECT city, temp_lo, temp_hi, prcp, date, location
FROM weather, cities
WHERE city = name;
```

Так как все столбцы имеют разные имена, анализатор таблицы автоматически понимает, к какой таблице они относятся. Если бы имена столбцов в двух таблицах повторялись, пришлось бы конкретизировать имена столбцов.

```sql
SELECT weather.city,
       weather.temp_lo,
       weather.temp_hi,
       weather.prcp,
       weather.date,
       cities.location
FROM weather, cities
WHERE cities.name = weather.city;
```

Хорошим стилем считается указывать полные имена столбцов в запросе соединения, чтоб запрос не сломался, если позже в таблицы будут добавлены столбцы с повторяющимися именами.

Запросы соединения, показанные выше, можно записать в другой форме:

```sql
SELECT *
FROM weather INNER JOIN cities ON (weather.city = cities.name);
```

## Внешние соединения

В результате предыдущего соединения мы не получили записи о городе Hayward. Теперь мы хотим, чтобы запрос просканировал таблицу weather и для каждой ее строки нашел соответствующую строку в таблице cities. Если же такая строка не будет найдена, мы хотим, чтобы вместо значений столбцов из таблицы cities были подставлены пустые значения. Запросы такого типа называются внешними соединениями.

```sql
SELECT *
FROM weather LEFT OUTER JOIN cities ON (weather.city = cities.name);
```

city | temp_lo | temp_hi | prcp | date | name | location
---: | ---: | ---: | ---: | ---: | ---: | ---:
Hayward | 37 | 54 | | 1994-11-29 | | |
San Francisco | 46 | 50 | 0.25 | 1994-11-27 | San Francisco | (-194, 53)
San Francisco | 43 | 57 | 0 | 1994-11-29 | San Francisco | (-194, 53)

Этот запрос называется _левым внешним соединением_, потому что из таблицы в левой части оператора будут выбраны все строки, а из таблицы справа только те, которые удалось сопоставить каким-нибудь строкам из левой. При выводе строк левой таблицы, для которых не удалось найти соответствия в правой, вместо столбцов правой таблицы подставляются NULL.

Существуют также правые внешние соединения и полные внешние соединения.

Соединением мы можем также замкнуть таблицу саму на себя. Это называется _замкнутым соединением_.

Например, мы хотим найти все записи погоды, в которых температура лежит в диапазоне других записей. Для этого мы должны сравнить столбцы temp_lo и temp_hi каждой строки таблицы weather со столбцами temp_lo и temp_hi другого набора строк weather.

```sql
SELECT w1.city,
       w1.temp_lo AS low,
       w1.temp_hi AS high,
       w2.city,
       w2.temp_lo AS low,
       w2.temp_hi AS high
FROM weather w1, weather w2
WHERE w1.temp_lo < w2.temp_lo AND
      w1.temp_hi > w2.temp_hi;
```

city | low | high | city | low | high
---: | ---: | ---: | ---: | ---: | ---:
San Francisco | 43 | 57 | San Francisco | 46 | 50
Hayward | 37 | 54 | San Francisco | 46 | 50
