# Числовые типы

Группа числовых типов состоит из:

* числа фиксированной точности
* числа с плавающей точкой
* последовательные типы (serial)

## Числа с фиксированной точностью

Числа с фиксированной точностью представлены двумя типами:

* `numerec`
* `decimal`

Эти типы идентичны по своим возможностям (по сути это одно и то же).

Для задания значения этого типа используются два базовых понятия: *масштаб (scale)* и *точность (precision)*. Масштаб показывает число значащих цифр, стоящих справа от десятичной точки. Точность указывает общее число цифр. Например, у числа 12.3456 точность составляет 6 цифр, а масштаб - 4 цифры.

```sql
numeric(точность, масштаб)
numeric(6, 4)
```

Главное достоинство этих чисел - обеспечение точных результатов при выполнении вычислений, когда это, конечно, возможно в принципе. Это оказывается возможным при выполнении сложения, вычитания и умножения. Однако точность достигается за счет замедления вычислений по сравнению с целочисленными типами и типами с плавающей точкой. При этом для хранения числа затрачивается больше памияти, чем в случае целых чисел.

Числа типа numeric могут хранить 131 072 цифру до десятичной точки и 16 383 после десятичной точки.

Данный тип следует выбирать для хранения денежных сумм, а также в других случаях, когда требуется гарантировать точность вычислений.

## Числа с плавающей точкой

Представителями являются типы `real`,  и `double precision`. Они представляют собой реализацию стандарта IEEE "Standard 754 for Binary Floating-Point Arithmetic".

Название | Псевдоним | Занимаемая память (байт) | Диапазон значений | Точность
--- | --- | --- | --- | ---
real | float4 | 4 | от 1E-37 до 1E+37 | До 6 знаков после запятой
double precision | float8 / float | 8 | от 1E-307 до 1E+308 | До 15 знаков после запятой

А также поддерживаются специальные значения:

* Infinity (бесконечность)
* -Infinity (отрицательная бесконечность)
* NaN (не число)

При попытке записать слишком большое или слишком маленькое число, будет генерироваться ошибка. Если точность вводимого числа выше допустимой, то дудет иметь место округление значения. При вводе очень маленьких чисел, которые невозможно представить значениями, отличными от нуля, будет генерироваться ошибка потери значимости, или исчезновения значщих разрядов (an underflow error).

Сравнение двух типов с плающей точкой на предмет равенства может привести к неожиданным результатам:

```sql
SELECT 0.1::real * 10 = 1.0::real;

 ?column?
----------
f
```

### float

PostreSQL поддерживает тип данных `float`, определенный в стандарте SQL. При объявлении типа может ипользоваться параметр `float(p)`. Если его значение лежит в диапазоне от 1 до 24, то это будет равносильно использованию типа `real`, а если значение лежит в диапазоне от 25 до 53, то это будет равносильно использованию типа `double precision`. Если при объявлении типа парамер не используется, то это равносильно использованию типа `double precision`.

## serial

### Недостатки типа serial

Предположим, у нас есть таблица с полем id типа serial. При вставке новых записей, значение поля автоинкрементируется и мы получаем значения id = 1, 2, 3,.... Допостим, последнее запись имеет значение id = 10. Ничто не мешает вставить новую запись, указав явно значение id = 11. Однако, когда после этого мы будем пытаться вставить новую запись, не указывая id явно, мы получи ошибку, что первичный ключ не удовлетворяет условию уникальности. Так происходит, потому что счетчик остановился на значении 10 и пытается вставить следующее значение 11. Он ничего не знает, о том, что мы вставили это значени руками.

## Identity

Чтобы устранить описанные выше недостатки типа serial, в Postgresql, начиная с версии 10 появился новый синтаксис создания полей с автоинкрементом. Этот синтаксис является рекомендуемым.

```sql
CREATE TABLE book
(
    book_id int GENERATED ALWAYS AS IDENTITY,
    title text NOT NULL,
    CONSTRAINT PK_book PRIMARY KEY (book_id)
);

-- вместо ALWAYS можно использовать BY DEFAULT
CREATE TABLE book
(
    book_id int GENERATED BY DEFAULT AS IDENTITY,
    ...
);
```

В обоих случаях при вставке записей, где значение book_id не задано, оно будет автоинкрементироваться. Отличия появляются, когда мы пытаемся задать book_id явно.

В случае ALWAYS при попытке вставить новую строку, где значение book_id задано явно, мы получим ошибку. Таким образом, просто так вставить значение не получится. Однако, это ограничение можно обойти, модирнизировар команду INSERT

```sql
INSERT INTO book
OVERRIDING SYSTEM VALUE
VALUES (11, 'title');
```

Таким образом, используя простую команду INSERT мы не сможем вставить значение руками. Теперь пользователь предупрежден, что лезть руками в это поле не следует, и если он использует OVERRIDING SYSTEM VALUE, то делает это на свой страх и риск.

В случае BY DEFAULT поведение будет примерно таким же как и у поля serial: мы сможем руками задать значение book_id, этом, мы никак не будем предупреждены, что делать так не стоит.

Дополнительные опции

```sql
CREATE TABLE book
(
    book_id int GENERATED ALWAYS AS IDENTITY (START WITH 10 INCREMENT BY 2),
    ...
);
```

* START WITH - с какого значения стартовать счетчик
* INCREMENT BY - шаг инкремента

Identity также как и serial базируется на последовательностях, но внутри устроен немного сложнее.

Использоване IDENTITY имеет еще ряд преимуществ по сравнению с serial.

1. Этот подход больше соответствует стандарту SQL и поддерживается большим числом СУБД.
2. Последовательностями легче управлять.

   При использовании serial, чтобы, например перезапустить счетчик, нужно знать имя последовательности, чтобы обратиться к ней. В случае с IDENTITY, последовательностью можно управлять через имя столбца

```sql
ALTER TABLE book
ALTER COLUMN book_id RESTART WITH 10;
```
